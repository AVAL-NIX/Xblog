Index: xblog/src/main/java/com/blog/controller/common/FileController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.blog.controller.common;\r\n\r\nimport com.blog.common.constants.AppConstants;\r\nimport com.blog.common.utils.QiNiuApiUtil;\r\nimport com.blog.common.utils.WebUtils;\r\nimport com.blog.model.bean.ResultData;\r\nimport com.qiniu.http.Response;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RequestParam;\r\nimport org.springframework.web.bind.annotation.RestController;\r\nimport org.springframework.web.multipart.MultipartFile;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.util.UUID;\r\n\r\n/**\r\n * 文件上传控制类\r\n *\r\n * @author zx\r\n * @date 2019/3/30\r\n */\r\n@RequestMapping(\"/file\")\r\n@RestController\r\n@Slf4j\r\npublic class FileController extends BaseController {\r\n\r\n    @RequestMapping(\"/upload\")\r\n    public ResultData upload(@RequestParam(\"multipartFile\") MultipartFile multipartFile) {\r\n        // 权限验证\r\n        ResultData r = getAdminByAccessToken();\r\n        if (!r.isOk()) {\r\n\r\n            return r;\r\n        }\r\n        if (multipartFile.isEmpty()) {\r\n\r\n            return ResultData.error(\"上传失败\");\r\n        }\r\n        String fileName = UUID.randomUUID().toString();\r\n        String filePath = WebUtils.getProjectUrl() + AppConstants.UPLOAD_PATH;\r\n        File fileDir = new File(filePath);\r\n        if (!fileDir.exists()) {\r\n            fileDir.mkdir();\r\n        }\r\n       // File dest = new File(filePath + fileName);\r\n        try {\r\n            //上传到7牛云 filename 用于访问要用到最好保存  Response 还有其他数据可输出\r\n            Response rs = QiNiuApiUtil.uploadFileToQiNiu(multipartFile.getBytes(), fileName);\r\n\r\n            if(rs == null){\r\n                //上传失败\r\n                ResultData.error(\"上传失败\");\r\n            }\r\n\r\n            if(rs.statusCode == 200) {\r\n                // fileName 浏览也许需要\r\n                log.info(\"上传成功! \" + fileName);\r\n                return ResultData.ok(WebUtils.getBaseUrl() + AppConstants.UPLOAD_PATH + fileName);\r\n            }\r\n\r\n        } catch (IOException e) {\r\n            log.error(\"上传异常!\", e);\r\n        }\r\n        return ResultData.error(\"上传失败\");\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- xblog/src/main/java/com/blog/controller/common/FileController.java	(revision 327ae7364259921fe2c76ede8ae4d24e77f54326)
+++ xblog/src/main/java/com/blog/controller/common/FileController.java	(date 1627712827215)
@@ -3,6 +3,7 @@
 import com.blog.common.constants.AppConstants;
 import com.blog.common.utils.QiNiuApiUtil;
 import com.blog.common.utils.WebUtils;
+import com.blog.model.annotation.PassToken;
 import com.blog.model.bean.ResultData;
 import com.qiniu.http.Response;
 import lombok.extern.slf4j.Slf4j;
@@ -11,7 +12,6 @@
 import org.springframework.web.bind.annotation.RestController;
 import org.springframework.web.multipart.MultipartFile;
 
-import java.io.File;
 import java.io.IOException;
 import java.util.UUID;
 
@@ -27,6 +27,7 @@
 public class FileController extends BaseController {
 
     @RequestMapping("/upload")
+    @PassToken
     public ResultData upload(@RequestParam("multipartFile") MultipartFile multipartFile) {
         // 权限验证
         ResultData r = getAdminByAccessToken();
@@ -39,22 +40,22 @@
             return ResultData.error("上传失败");
         }
         String fileName = UUID.randomUUID().toString();
-        String filePath = WebUtils.getProjectUrl() + AppConstants.UPLOAD_PATH;
-        File fileDir = new File(filePath);
-        if (!fileDir.exists()) {
-            fileDir.mkdir();
-        }
-       // File dest = new File(filePath + fileName);
+//        String filePath = WebUtils.getProjectUrl() + AppConstants.UPLOAD_PATH;
+//        File fileDir = new File(filePath);
+//        if (!fileDir.exists()) {
+//            fileDir.mkdir();
+//        }
+        // File dest = new File(filePath + fileName);
         try {
             //上传到7牛云 filename 用于访问要用到最好保存  Response 还有其他数据可输出
             Response rs = QiNiuApiUtil.uploadFileToQiNiu(multipartFile.getBytes(), fileName);
 
-            if(rs == null){
+            if (rs == null) {
                 //上传失败
                 ResultData.error("上传失败");
             }
 
-            if(rs.statusCode == 200) {
+            if (rs.statusCode == 200) {
                 // fileName 浏览也许需要
                 log.info("上传成功! " + fileName);
                 return ResultData.ok(WebUtils.getBaseUrl() + AppConstants.UPLOAD_PATH + fileName);
Index: xblog/src/main/java/com/blog/interceptor/AuthenticationInterceptor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.blog.interceptor;\r\n\r\nimport com.auth0.jwt.JWT;\r\nimport com.auth0.jwt.JWTVerifier;\r\nimport com.auth0.jwt.algorithms.Algorithm;\r\nimport com.auth0.jwt.exceptions.JWTDecodeException;\r\nimport com.auth0.jwt.exceptions.JWTVerificationException;\r\nimport com.blog.model.annotation.PassToken;\r\nimport com.blog.model.bean.ResultData;\r\nimport com.blog.model.entity.Admin;\r\nimport com.blog.service.AdminService;\r\nimport org.apache.commons.lang3.math.NumberUtils;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.web.method.HandlerMethod;\r\nimport org.springframework.web.servlet.HandlerInterceptor;\r\nimport org.springframework.web.servlet.ModelAndView;\r\n\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.lang.reflect.Method;\r\n\r\npublic class AuthenticationInterceptor implements HandlerInterceptor {\r\n\r\n    @Autowired\r\n    AdminService adminService;\r\n\r\n    @Override\r\n    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object object) throws Exception {\r\n\r\n        // 如果不是映射到方法直接通过\r\n        if (!(object instanceof HandlerMethod)) {\r\n            return true;\r\n        }\r\n        HandlerMethod handlerMethod = (HandlerMethod) object;\r\n        Method method = handlerMethod.getMethod();\r\n        //检查是否有passtoken注释，有则跳过认证\r\n        if (method.isAnnotationPresent(PassToken.class)) {\r\n            PassToken passToken = method.getAnnotation(PassToken.class);\r\n            if (passToken.required()) {\r\n                return true;\r\n            }\r\n        }\r\n        // 从 http 请求头中取出 token\r\n        String token = httpServletRequest.getHeader(\"login-token\");\r\n        // 执行认证\r\n        if (token == null) {\r\n            throw new RuntimeException(\"无token，请重新登录\");\r\n        }\r\n        // 获取 token 中的 user id\r\n        String id;\r\n        try {\r\n            id = JWT.decode(token).getAudience().get(0);\r\n        } catch (JWTDecodeException j) {\r\n            throw new RuntimeException(\"401\");\r\n        }\r\n        ResultData<Admin> resultData = adminService.findById(NumberUtils.toLong(id));\r\n        if (!resultData.isOk()) {\r\n            throw new RuntimeException(\"用户不存在，请重新登录\");\r\n        }\r\n        Admin admin = resultData.getData();\r\n        // 验证 token\r\n        JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(admin.getPassword())).build();\r\n        try {\r\n            jwtVerifier.verify(token);\r\n        } catch (JWTVerificationException e) {\r\n            throw new RuntimeException(\"401\");\r\n        }\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void postHandle(HttpServletRequest httpServletRequest,\r\n                           HttpServletResponse httpServletResponse,\r\n                           Object o, ModelAndView modelAndView) throws Exception {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void afterCompletion(HttpServletRequest httpServletRequest,\r\n                                HttpServletResponse httpServletResponse,\r\n                                Object o, Exception e) throws Exception {\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- xblog/src/main/java/com/blog/interceptor/AuthenticationInterceptor.java	(revision 327ae7364259921fe2c76ede8ae4d24e77f54326)
+++ xblog/src/main/java/com/blog/interceptor/AuthenticationInterceptor.java	(date 1627715365556)
@@ -9,16 +9,22 @@
 import com.blog.model.bean.ResultData;
 import com.blog.model.entity.Admin;
 import com.blog.service.AdminService;
+import lombok.extern.slf4j.Slf4j;
+import net.sf.json.JSONObject;
 import org.apache.commons.lang3.math.NumberUtils;
 import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.MediaType;
 import org.springframework.web.method.HandlerMethod;
 import org.springframework.web.servlet.HandlerInterceptor;
 import org.springframework.web.servlet.ModelAndView;
 
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
+import java.io.IOException;
 import java.lang.reflect.Method;
 
+@Slf4j
 public class AuthenticationInterceptor implements HandlerInterceptor {
 
     @Autowired
@@ -40,30 +46,37 @@
                 return true;
             }
         }
-        // 从 http 请求头中取出 token
-        String token = httpServletRequest.getHeader("login-token");
-        // 执行认证
-        if (token == null) {
-            throw new RuntimeException("无token，请重新登录");
-        }
-        // 获取 token 中的 user id
-        String id;
-        try {
-            id = JWT.decode(token).getAudience().get(0);
-        } catch (JWTDecodeException j) {
-            throw new RuntimeException("401");
-        }
-        ResultData<Admin> resultData = adminService.findById(NumberUtils.toLong(id));
-        if (!resultData.isOk()) {
-            throw new RuntimeException("用户不存在，请重新登录");
-        }
-        Admin admin = resultData.getData();
-        // 验证 token
-        JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(admin.getPassword())).build();
-        try {
+        try {
+            // 从 http 请求头中取出 token
+            String token = httpServletRequest.getHeader("login-token");
+            // 执行认证
+            if (token == null) {
+                responseResult(httpServletResponse, ResultData.error("无token，请重新登录"));
+                return false;
+            }
+            // 获取 token 中的 user id
+            String id = JWT.decode(token).getAudience().get(0);
+            ResultData<Admin> resultData = adminService.findById(NumberUtils.toLong(id));
+            if (!resultData.isOk()) {
+                responseResult(httpServletResponse, ResultData.error("用户不存在，请重新登录"));
+                return false;
+            }
+            Admin admin = resultData.getData();
+            // 验证 token
+            JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(admin.getPassword())).build();
             jwtVerifier.verify(token);
+        } catch (JWTDecodeException e) {
+            log.error(" 异常", e);
+            responseResult(httpServletResponse, ResultData.error("权限验证失败"));
+            return false;
         } catch (JWTVerificationException e) {
-            throw new RuntimeException("401");
+            log.error(" 异常", e);
+            responseResult(httpServletResponse, ResultData.error("权限验证失败"));
+            return false;
+        } catch (Exception e) {
+            log.error(" 异常", e);
+            responseResult(httpServletResponse, ResultData.error("用户登录失败"));
+            return false;
         }
         return true;
     }
@@ -81,4 +94,15 @@
                                 Object o, Exception e) throws Exception {
     }
 
+
+    private void responseResult(HttpServletResponse response, ResultData result) throws IOException {
+        String temp = JSONObject.fromObject(result).toString();
+        response.setCharacterEncoding("UTF-8");
+        response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);
+        response.setStatus(HttpStatus.FORBIDDEN.value());
+        response.getWriter().flush();
+        response.getWriter().write(temp);
+        response.getWriter().close();
+        log.error(temp);
+    }
 }
\ No newline at end of file
