---
submitToken: 0FD67C48AD96D09E1708B69164B3714AD78879FF3F20F8E2C4B4EBEF6600170D
title: 设计模式的分类有哪些
channel: topic
labels: 设计模式
---

## 设计模式的分类

1. ### **创造型设计模式**
    > 注重完成对象的实例化，相比于直接实例化对象，根据实际情况选择合适的设计模式完成对象的实例化，可以为复杂的业务场景带来更高的灵活性

    **创造型设计模式主要包括以下几种：**

    - 抽象工厂设计模式
        >提供一个用于创建相关对象或相互依赖对象的接口，无需指定对象的具体类

    - 生成器设计模式
        >将复杂对象的构建与其表示相互分离，使得同样的构建过程可以创建不同的表示

    - 工厂方法设计模式
        >允许在子类中实现本类的实例化类

    - 原型设计模式
        >使用一个原型实例来指定创建对象的种类，然后通过拷贝这些原型实现新对象的创建

    - 单例设计模式
        >确保某个类在系统中仅有一个实例，并提供一个访问它的全局访问点

2. ### **结构型设计模式**
    > 结构型设计模式用于指导我们完成对代码的结构划分，如此，代码结构会更加清晰，更易理解，也提高了软件的可维护性。

    **结构型设计模式主要包括以下几种：**

    - 适配器设计模式
        >允许我们为一个已有的类提供一个新的接口，并在客户端请求不同接口时实现类的重用。

    - 桥接设计模式
        >允许我们将类与其接口相互解耦。允许类及其接口随着时间相互独立变化，增加类重用的次数，提高后续可扩展性。它也允许运行时对接口的不同实现方式动态切换，使代码更加灵活。

    - 组合设计模式
        >它能够为客户端处理各种复杂和灵活的树状结构。这些树结构可以由各种不同类型的容器和叶节点组成，其深度或组合形式能够在运行时调整或确定。

    - 装饰设计模式
        >允许我们通过附加新的功能或修改现有功能，在运行时动态地修改对象。

    - 门面设计模式
        >允许我们为客户端创建一个统一的接口以访问不同子系统的不同接口，从而简化客户端。

    - 享元设计模式
        >客户端调用类时会在运行时创建大量对象，该模式会重新设计类以优化内存开销。

    - 代理设计模式
        >为其他对象提供一种代理以控制对这个对象的访问。这种模式的目的是一个对象不适合或者不能直接引用另一个对象，简化客户端并实现对象访问，同时避免任何副作用。

3. ### **行为型设计模式**
    > 行为型设计模式主要用于定义对象之间的通信与流程控制，主要的设计模式都非常注重优化对象之间的数据交互方式。

    **行为型设计模式主要包括以下几种：**

    - 职责链设计模式
        >在一系列对象链之间传递请求的方法。

    - 命令设计模式
        >命令模式主要用于在需要向对象发出请求的情况，发出请求的对象无须了解请求的操作内容，也无须了解请求的实际接收对象。

    - 解释器设计模式
        >解释器提供了在代码中使用特定语言的一种方法。解释器模式就是一种用于在程序中解析特定语言的设计模式。

    - 迭代器设计模式
        >迭代器用于顺序访问集合（组合）对象中的元素，而无须了解其内部结构。

    - 中介者设计模式
        >定义简单的类间通信。

    - 备忘录设计模式
        >捕获和恢复对象的内部状态。

    - 观察者设计模式
        >一种通知多个类进行改变的方式。

    - 策略设计模式
        >在类中进行算法封装。

    - 状态设计模式
        >当一个对象状态改变时改变其功能。

    - 模板方法设计模式
        >将算法中的部分步骤延迟到子类中进行计算。
    
    - 访问者设计模式
        >在不改变类的条件下为该类定义一个新的操作。
