---
submitToken: 78A10301B5D79859C448619FA41EB3C8DE28C3D999FC3D2C7DD286937C3EE2A3
title: MVCC是如何实现的?
channel: topic
labels: mysql
---


MVCC的话是多版本并发控制，在数据库的每一行后面都有一个隐藏的列，记录的事务的id和指向undolog的指针， undolog的指针又指向更早版本的undolog，通过隐藏的列和undolog可以把数据恢复到任一版本，然后还有一个readview，可重复读是在事务执行之后，第一个select语句之前生成readview，可以解决脏读，不可重复读，幻读的问题，读已提交是在事务执行之后，每个select之前生成readview，可以解决脏读的问题，但是解决不了不可重复读，幻读的问题（这里的话我本来是想举几个例子来说明一下，但是不知道怎么举，怕面试官理解不了我的想法）

它们是怎么解决的呢，是通过三方面的比较实现的，拿数据事务的id和下一个要分配的事务id（low_limit_id）进行比较，如果比low_limit_id小才可见，拿数据的事务id和当前活跃事务的最小id（up_limit_id）进行比较，如果比up_limit_id小才可见，可重复读会在事务执行之后，第一个select语句之前生成readview，保存了当前活跃事务的id，如果数据的事务id在活跃事务中，那么是不可见的，否则是可见的（这段话因为紧张没有说出来）

还有一种方式是加锁读，通过加共享锁和排他锁实现，共享锁的话是如果一个数据要读取数据，那么就会加共享锁，加了共享锁一种就只能加共享锁，不能再加排他锁；排他锁的话是一个事务如果要修改数据就会加排他锁，加了排他锁就什么锁都不能再加了，这样可以解决脏读，不可重复读的问题
如果要解决幻读的问题，还需要用到next-key lock，这个是行锁 和 间隙锁的结合，间隙锁指的是锁住一段数据的间隙，不锁存在的数据，next-key lock的话就是即要锁数据也要锁间隙，就可以解决幻读的问题；