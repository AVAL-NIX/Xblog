---
submitToken: 8288DC2D92C473393F4C3E0FE06B3D5E01569026449C606A1A273FCABDE44DA2
title: 偏向锁/轻量级锁/重量级锁的原理?
channel: topic
labels: juc
---

- 偏向锁

在实际应用运行过程中发现，“锁总是同一个线程持有，很少发生竞争”，也就是说锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程。

那么只需要在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁，直到竞争发生才释放锁。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，如果一致直接进入同步，退出同步也，无需每次加锁解锁都去CAS更新对象头，如果不一致意味着发生了竞争，锁已经不是总是偏向于同一个线程了，这时候需要锁膨胀为轻量级锁，才能保证线程间公平竞争锁

1.加锁

偏向锁加锁发生在偏向线程第一次进入同步块时，CAS原子操作尝试更新对象的Mark Word（偏向锁标志位为"1"，记录偏向线程的ID）。

2.撤销偏向锁

当有另一个线程来竞争锁的时候，就不能再使用偏向锁了，要膨胀为轻量级锁。
竞争线程尝试CAS更新对象头失败，会等待到全局安全点（此时不会执行任何代码）撤销偏向锁

第一次获取的锁的线程 修改偏向锁标志位

- 轻量级锁

轻量锁与偏向锁不同的是：

轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁
每次进入退出同步块都需要CAS更新对象头
争夺轻量级锁失败时，自旋尝试抢占锁
 可以看到轻量锁适合在竞争情况下使用，其自旋锁可以保证响应速度快，但自旋操作会占用CPU，所以一些计算时间长的操作不适合使用轻量级锁。

1.加锁
 加锁过程和偏向锁加锁差不多，也是CAS修改对象头，只是修改的内容不同。

在MarkWord中保存当前线程的指针
修改锁标识位为“00”
 采用CAS操作的原因是，不想在加锁解锁上再加同步

如果对象处于无锁状态（偏向锁标志位为"0"，锁标志位为"01"），会在线程的栈中开辟个锁记录空间（Lock Record），将Mark Word拷贝一份到Lock Record中，称为Displaced Mark Word，在Lock Record中保存对象头的指针（owner）。
接下来CAS更新MarkWord，将MarkWord指向当前线程，owner指向MarkWord，如果失败了，则意味着出现了另一个线程竞争锁，此时需要锁膨胀为轻量级锁。

CAS修改对象头

锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

- 重量级锁

底层是操作系统级别的锁了。 用了monitor对象

monitor对象 的解释：

> 在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor实现的。每个对象中都内置了一个 ObjectMonitor对象。
在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。
在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。
类似CAS操作