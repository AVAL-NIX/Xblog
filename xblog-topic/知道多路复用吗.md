---
submitToken: 32638F4922641802E41618879068CACB3937F350ED1D6B970E1DAF1FCD40AE73
title: linux连接模型?
channel: topic
labels: redis
---


## 五种IO模型

- 阻塞式I/O
- 非阻塞式I/O
- I/O复用（select，poll，epoll等）
- 信号驱动式I/O（SIGIO）
- 异步I/O（POSIX的aio_系列函数）

IO执行的两个阶段
　　在Linux中，对于一次读取IO的操作，数据并不会直接拷贝到程序的程序缓冲区。通常包括两个不同阶段：
　（1）等待数据准备好，到达内核缓冲区；
　（2）从内核向进程复制数据。
　　对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所有等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用程序缓冲区。

## 阻塞式I/O模型：
　　同步阻塞 IO 模型是最常用、最简单的模型。在linux中，默认情况下，所有套接字都是阻塞的。 下面我们以阻塞套接字的recvfrom的的调用图来说明阻塞：
![](https://image.avalon-zheng.xin/e916c262-0533-46d1-b449-c2d07f343372 "")
　　进程调用一个recvfrom请求，但是它不能立刻收到回复，直到数据返回，然后将数据从内核空间复制到程序空间。
　　在IO执行的两个阶段中，进程都处于blocked(阻塞)状态，在等待数据返回的过程中不能做其他的工作，只能阻塞的等在那里。
　　
优缺点：
　　优点是简单，实时性高，响应及时无延时，但缺点也很明显，需要阻塞等待，性能差；

## 非阻塞式I/O：
　　与阻塞式I/O不同的是，非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error（EAGAIN 或 EWOULDBLOCK）。进程在返回之后，可以处理其他的业务逻辑，过会儿再发起recvform系统调用。采用轮询的方式检查内核数据，直到数据准备好。再拷贝数据到进程，进行数据处理。
　　在linux下，可以通过设置socket套接字选项使其变为非阻塞。下图是非阻塞的套接字的recvfrom操作
![](https://image.avalon-zheng.xin/dcebf987-7f53-4b8f-a1c1-f568e452f979 "")
　　如上图，前三次调用recvfrom请求，但是并没有数据返回，所以内核返回errno(EWOULDBLOCK)，并不会阻塞进程。但是当第四次调用recvfrom，数据已经准备好了，然后将它从内核空间拷贝到程序空间，处理数据。
　　在非阻塞状态下，IO执行的等待阶段并不是完全的阻塞的，但是第二个阶段依然处于一个阻塞状态。
　　
同步非阻塞方式相比同步阻塞方式：
　　优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。
　　缺点：任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。

## I/O多路复用（select，poll，epol）：
　　IO 多路复用的好处就在于单个进程就可以同时处理多个网络连接的IO。它的基本原理就是不再由应用程序自己监视连接，取而代之由内核替应用程序监视文件描述符。
　　以select为例，当用户进程调用了select，那么整个进程会被阻塞，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从内核拷贝到用户进程。如图：
![](https://image.avalon-zheng.xin/a502c871-4d51-4014-83ad-8dc33f50691e "")
　　这里需要使用两个system call (select 和 recvfrom)，而阻塞 IO只调用了一个system call (recvfrom)。所以，如果处理的连接数不是很高的话，使用IO复用的服务器并不一定比使用多线程+非阻塞阻塞 IO的性能更好，可能延迟还更大。IO复用的优势并不是对于单个连接能处理得更快，而是单个进程就可以同时处理多个网络连接的IO。
　　实际使用时，对于每一个socket，都可以设置为非阻塞。但是，如上图所示，整个用户的进程其实是一直被阻塞的。只不过进程是被select这个函数阻塞，而不是被IO操作给阻塞。所以IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用（如recvfrom）。

优势
　　与传统的多线程/多进程模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源。
主要应用场景：
　　①、服务器需要同时处理多个处于监听状态或者多个连接状态的套接字；
　　②、服务器需要同时处理多种网络协议的套接字，如同时处理TCP和UDP请求；
　　③、服务器需要监听多个端口或处理多种服务；
　　④、服务器需要同时处理用户输入和网络连接。

## 信号驱动式I/O
　　允许Socket进行信号驱动IO,并注册一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。如下图：
![](https://image.avalon-zheng.xin/bd9d1f39-287d-4b49-b935-46fcf0112217 "")
　　阻塞在IO操作的第二阶段

## 异步I/O模型：
　　上述四种IO模型都是同步的。相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，就可以去处理其他的逻辑了，无论内核数据是否准备好，都会直接返回给用户进程，不会对进程造成阻塞。等到数据准备好了，内核直接复制数据到进程空间，然后从内核向进程发送通知，此时数据已经在用户空间了,可以对数据进行处理了。
　　在 Linux 中，通知的方式是 “信号”，分为三种情况：
　　①、如果这个进程正在用户态处理其他逻辑，那就强行打断，调用事先注册的信号处理函数，这个函数可以决定何时以及如何处理这个异步任务。由于信号处理函数是突然闯进来的，因此跟中断处理程序一样，有很多事情是不能做的，因此保险起见，一般是把事件 “登记” 一下放进队列，然后返回该进程原来在做的事。
　　②、如果这个进程正在内核态处理，例如以同步阻塞方式读写磁盘，那就把这个通知挂起来了，等到内核态的事情忙完了，快要回到用户态的时候，再触发信号通知。
　　③、如果这个进程现在被挂起了，例如陷入睡眠，那就把这个进程唤醒，等待CPU调度，触发信号通知。
![](https://image.avalon-zheng.xin/52952e35-468b-497c-b46a-7a4ab4fd8acb "")
　　IO两个阶段，进程都是非阻塞的。

五种IO模型比较

　　其实前四种I/O模型都是同步I/O操作，他们的区别在于第一阶段，而他们的第二阶段是一样的：在数据从内核复制到应用缓冲区期间（用户空间），进程阻塞于recvfrom调用。相反，异步I/O模型在这等待数据和接收数据的这两个阶段里面都是非阻塞的，可以处理其他的逻辑用户进程将整个IO操作交由内核完成，内核完成后会发送通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。
